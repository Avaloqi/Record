# 日常开发常用的各类关键字
## Const
### 基本作用
const 关键字的作用是向编译器声明一个变量是“常量”或“只读”的。它主要有两种用途：声明存储位置（决定是否进入 .rodata）和定义访问权限（限制修改）  
大多数情况下，使用const声明全局变量或静态变量可以节省RAM  
**节省 RAM 的机制** 
防止复制到 RAM (.data区)：  
    非 const 全局变量 必须存储在 RAM 的 .data 区，因为它们的值可以在运行时被修改。程序启动时，这些变量的初始值需要从 Flash/ROM 复制到 RAM 中。  
    const 全局变量 存储在 Flash/ROM 的 .rodata 区。它们不需要被复制到 RAM 中，因此节省了那一部分 RAM 空间。  
可能被优化 (零存储)：  
    对于简单的、已知值的 const 变量（例如 const int VALUE = 10;），编译器可能完全不为其分配存储空间。  
    相反，编译器会在所有使用该变量的地方，直接用其数值（即 10）替换变量名。这种优化称为常量折叠 (Constant Folding) 或 字面量替换。在这种情况下，它不仅节省了 RAM，连 Flash/ROM 空间也得到了最优化。  
**声明存储位置**
存储区段分析：const 变量的存储区段主要取决于其作用域（全局/静态）以及它是否被初始化。  
A.全局或静态的 const 变量 (例如 const int MAX_VAL = 100;)  
存储位置：通常存储在 只读数据区 (Read-Only Data Section)，通常命名为 .rodata 或类似于 .constdata 的区段。    
物理位置：   
在大多数嵌入式系统中，.rodata 区段的数据在程序启动时被加载到 Flash/ROM (非易失性存储器) 中。  
    原因： 编译器知道这些变量的值永远不会改变，因此将它们放在只读存储器中可以保护它们不被意外修改，并且由于它们是常量，可以节省宝贵的 RAM 空间。  
    特例： 如果目标硬件没有独立的 Flash/ROM 访问机制（例如，一些简单的微控制器），或者如果变量的地址需要被写入 RAM，编译器可能仍会将其存储在 数据区 (.data) 并标记为只读，但这在现代嵌入式系统和编译器中不常见。  
B.局部的 const 变量 (例如 void func() { const int x = 5; })    
存储位置：存储在栈区（Stack）    
    原因： 局部变量（无论是否为 const）通常在函数调用时创建，并在栈上分配空间。一旦函数返回，这块内存就被释放。  

**定义访问权限**  
const 的位置不同，其限制作用也完全不同  
1. 结构体声明中的 const  
    当 const 作用于结构体（struct）时，它可以放在类型定义时，也可以放在变量定义时。  
    A. 作用于整个结构体变量  
        这是最常见的用法，const 放在结构体类型名的前面。  

    | 声明方式 | 作用 | 限制 |
    | --- | --- | --- |
    | const struct S my_struct;| 结构体只读	| 不能修改 my_struct 结构体中的任何成员|
    | struct S const my_struct;| 效果与上一个相同| C 语言中，将 const 放在类型之后、变量名之前，效果是等价的，表示该变量本身是常量。但第一种写法更常用|

2. 指针声明中的 const
    这是最容易混淆的部分。对于指针变量 char *p;，const 可以放在三个位置，限制指针本身或它指向的数据。  
    假设我们有一个指针 char *p;

    | 位置	| 示例	| 作用	| 限制/说明|
    |---|---|---|---|
    |I. 指向的数据是常量	|const char *p;	|限制数据	|不能通过 p 来修改它指向的数据。 你可以修改指针 p 本身，让它指向别处。|
    |II. 指针本身是常量	|char *const p;	|限制指针	|不能修改指针 p 本身（即不能让它指向别处）。你可以修改它指向的数据。|
    |III. 数据和指针都是常量	|const char *const p;	|限制数据和指针	|既不能修改它指向的数据，也不能修改指针 p 本身。|
    💡 记忆技巧
    理解指针 const 声明的关键在于：const 总是作用于它左边的内容。如果左边没有东西，它就作用于右边。  
    const char *p;
        const 左边是 char，作用于 char（数据类型）。
        含义： p 指向的 char 是常量（只读）。
    char *const p;
        const 左边是 *，作用于 *（指针标记）。
        含义： 指针 p 本身是常量（只读）。
    const char *const p;
        第一个 const 作用于 char (数据)。
        第二个 const 作用于 * (指针)。

3. 函数参数和返回值的 const
    A. 作为函数参数
    在函数参数中使用 const 是保护传入数据的一种契约。
    示例
    void print_data(const struct S *p);
    只读指针在函数 print_data 内部，不能通过 p 修改传入的结构体数据。这避免了对外部数据的意外修改，是安全编码的最佳实践。
    void copy_data(char *const p);
    指针常量函数内部不能修改指针 p 本身的值（不能指向另一个地址），但可以修改 p 指向的数据。B. 作为函数返回值声明示例作用限制const char *get_name();返回只读数据返回一个指向只读字符串的指针。调用者接收到这个指针后，不能通过它修改字符串内容。这常用于返回存储在 .rodata 中的全局
    B. 作为函数返回值
    const char *get_name();
    返回只读数据返回一个指向只读字符串的指针。调用者接收到这个指针后，不能通过它修改字符串内容。这常用于返回存储在 .rodata 中的全局字符串。
4. const 与 volatile 的结合
    在嵌入式系统中，有时会看到 const volatile 的组合。
        const: 告诉编译器程序代码不会修改这个变量。
        volatile: 告诉编译器这个变量可能会被程序代码之外的东西修改（例如，硬件寄存器、中断服务程序）。
        示例
        const volatile uint32_t STATUS_REG;
        这是一个只读的硬件状态寄存器。程序代码不能写入（const），但硬件可以随时改变它的值（volatile）。
        这种组合在访问硬件寄存器（例如状态标志、只读 ID 寄存器）时非常常见。

### 使用细节
除了上面提到的作用域、存储位置和指针限制之外，const 在 C 语言嵌入式开发中还有一些重要的知识点和细节，它们对代码优化、安全性和内存管理至关重要。
#### const 和宏定义 (#define) 的区别
在 C 语言中，宏定义 (#define) 和 const 变量都可以用来定义常量，但在安全性、类型检查和内存使用方面有显著区别：

|特性	| const 变量 (例如 const int MAX = 10;)	| 宏定义 (例如 #define MAX 10)|
|---|---|---|
|类型检查	|有。编译器可以检查其类型（int, float, char * 等）。	|无。在预处理阶段简单地进行文本替换。|
|调试支持	|支持。可以在调试器中查看变量地址和值。	不支持。宏在预处理后即消失。|
|内存使用	|可能分配存储空间（.rodata），但也可能被优化掉（常量折叠）。	|无存储空间。每次使用都会被替换为字面值。|
|表达式副作用	|安全。不会产生意外的副作用。	|不安全。如果宏包含表达式，可能导致重复求值和副作用。|
|最佳实践	|推荐用于定义有类型、有作用域的常量。	|仅用于简单的数值或防止编译错误（如头文件包含卫士）。|
#### const 在头文件中的使用
对于需要在多个源文件 (.c) 中共享的常量，const 变量的处理方式有两种：
1.外部链接 (External Linkage) - 仅在头文件中声明
如果只在头文件中声明一个 const 变量，并在一个 .c 文件中定义它
Header (config.h):
```
extern const int MAX_BUFFER_SIZE; // 声明
```
Source (config.c):
```
const int MAX_BUFFER_SIZE = 1024; // 定义
```
作用： 确保这个常量在整个程序中只有一个实例（一个存储地址，在 .rodata 中）。

2.内部链接 (Internal Linkage) - 在头文件中定义并使用 static
如果你希望每个包含该头文件的 .c 文件都拥有自己的独立副本（尽管值相同），可以结合使用 const 和 static。
Header (config.h):
```
static const int MAX_RETRIES = 5; // static const
```
作用： 强制编译器为每个包含此头文件的 .c 文件都生成一个 MAX_RETRIES 的副本。这有时用于避免链接错误，但可能会略微增加代码段大小。

#### const 的传递性 (Transitivity) 陷阱
**结构体中的const传递性陷阱**
const 属性不会自动传递到它指向的数据结构内部。
示例
```
typedef struct {
    int a;
    int b;
} Data;

// A. 整个结构体变量是常量 (存储在 .rodata)
const Data GLOBAL_DATA = {10, 20};

// B. 指向 Data 结构体的只读指针
const Data *data_ptr = &GLOBAL_DATA;
```
陷阱的本质：
如果你声明一个 const Data *data_ptr;，这限制的是通过 data_ptr 这个路径去修改数据。但如果结构体 Data 内部的成员本身不是 const，并且存在其他非 const 的路径可以访问这块内存，那么数据是可以被修改的。
```
Data mutable_data = {1, 2};
const Data *ptr_c = &mutable_data; // 指向可修改数据的 const 指针
Data *ptr_m = &mutable_data;        // 指向可修改数据的 可修改指针

// 限制：通过 ptr_c 访问是只读的
// *ptr_c = {5, 6};  // 编译错误
// ptr_c->a = 5;     // 编译错误

// 绕过：通过 ptr_m 访问是可写的
ptr_m->a = 500; // ✅ 成功修改了 mutable_data 的 a

// 此时，通过 ptr_c 查看，值也变了
// printf("%d", ptr_c->a); // 输出 500
```
这证明 const 只是对指针变量本身施加了访问权限的限制，并没有改变它所指向内存的属性。
**多级指针中的 const 传递性陷阱 (核心问题)**
当涉及到多级指针（如 **p）时，const 属性的传递性表现出一种“不对称”的特点，这种不对称性允许某些“看似安全”的转换，但实际上会引发运行时错误。

❌ 不安全但编译器允许的隐式转换
最危险的陷阱是： C 语言允许将一个指向非 const 数据的指针的指针 (char \**) 隐式转换为一个指向** const 数据的指针的指针** (const char **)。
```
char *p_data = "Hello";        // 1. 指向可修改数据的指针 (如果是在堆或栈上)
char **p_ptr = &p_data;      // 2. 指向指针的指针

// 3. 不安全但编译器允许的隐式转换
const char **cp_ptr = p_ptr; // ❌ 警告，但在C语言中可能被隐式允许，这是陷阱所在！
```
为什么这种转换是危险的？ (打破 const 契约)
这个隐式转换创造了一个可以绕过 const 保护的后门。请看完整的利用过程：
1.准备环境： 
创建一个真正的常量字符串，它将存储在 .rodata 区（只读内存）。
```
const char *READ_ONLY_STR = "READ_ONLY"; // 存储在 .rodata
char *mutable_str = "MUTABLE";            // 存储在 .rodata 或 .data，取决于编译器，但我们假设它是可修改的。
```
2.设置后门：
```
// 非 const 的指针 p1，指向 mutable_str
char *p1 = mutable_str;

// 非 const 的指针的指针 p_ptr，指向 p1
char **p_ptr = &p1;

// 隐式转换：将 char ** 转换为 const char **
// 编译器可能允许此操作，认为这是“添加” const 保护
const char **cp_ptr = p_ptr; // 警告/允许
```
3.绕过保护： 
现在，利用 cp_ptr 的 const 契约来引入一个指向只读数据的指针。
```
// 4. 利用 cp_ptr 的 const 契约
// cp_ptr 是指向 const char * 的指针，因此它可以安全地指向 READ_ONLY_STR
*cp_ptr = READ_ONLY_STR; // ✅ 此时 *cp_ptr == p1，所以 p1 被修改为指向 READ_ONLY_STR!
```
4.非法写入 (触发段错误/总线错误)：
```
// p1 现在指向了 .rodata 中的 "READ_ONLY" 字符串
// p1 本身是非 const char * 类型！

printf("原始值: %s\n", p1); // 输出 READ_ONLY
// 尝试通过 p1 修改只读内存
*p1 = 'X'; // 💥 运行时错误 (Segmentation Fault 或 Bus Error)!
printf("新值: %s\n", p1);
```
总结：
允许 char ** 转换为 const char ** 打破了类型系统的保证。通过这个转换，你成功地将一个指向可写数据的指针 (p1) 替换成了指向只读数据的指针 (READ_ONLY_STR)，但 p1 的类型依然是可写的 (char *)，从而导致对只读内存的非法写入。

C 语言标准对此的规定：
C 标准委员会认为这种类型转换是危险的，但没有完全禁止，因为它在某些旧代码中是必要的。然而，现代编译器通常会发出警告，提示这种类型转换可能会导致问题。为了安全起见，应避免使用这种隐式转换，如果必须转换，应该使用显式强制类型转换 (casting) 并承担所有风险。

正确的安全转换 (添加 const):
安全且没有歧义的 const 转换应该是直接作用于数据：
```
const char *cp = p; // ✅ 安全，将 p 指向的数据声明为只读
```
#### const 与 C++ 的差异 (C++ vs C)
C++ 中的 const 默认是内部链接 (Internal Linkage)，类似于 C 中的 static const，即每个文件都有自己的副本，这有助于编译优化。  
C 语言中的 const 默认是外部链接 (External Linkage)，除非显式使用 static 关键字。  
在 C 嵌入式项目中，如果需要跨文件共享常量，必须使用 extern const 的声明/定义模式，以确保它们在链接时只存在一个实例。
